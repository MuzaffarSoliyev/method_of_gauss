Документация
============

Задача: Решение СЛАУ (Метод Гаусса с выбором главного элемента по столбцу)
--------------------------------------------------------------------------

Выполнил: Солиев Музаффар / Группа: М1-15
-------------------------------------------

==================
запуск программы:

> <название исполняемого файла>(.exe) <входной файл> <выходной файл> <аргументы>

Где аргументы:
  -d    	вывод в консоль сообщений отладки и хода решений [по-умолчанию откл]
  -e    	вывод ошибок [по-умолчанию откл]
  -p    	вывод матрицы в самом начале [по-умолчанию откл]
  -t    	вывод времени выполнения программы [по-умолчанию откл]
  -h, -?	справка
  
По умолчанию входной/выходной файл:
lss_46_02_in.txt
lss_46_02_out.txt
==================
error - флаг ошибок
debug - флаг отладки

Коды ошибки
	 0 - ошибок нет.
	-1 - входной файл не открыт.
	-2 - файл пуст либо количество уравений меньше нуля.
	-3 - не удалось выделить память.
	-4 - не удалось считать элемент матрицы.
	-5 - выходной файл не открыт.
	-6 - задана неверный аргумент.


______________________________________
double approximate(double num)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Аргументы:
double num - действительное число
- функция возвращает действительное число округлённое до epsilon.

______________________________________
size_t lss_memsize_46_02(int n)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Аргументы:
int n - целое число
- функция возвращает размер(в байтах) необходимый для массива с количеством элементов n.


______________________________________
void print(double *A, double *B, int n)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Аргументы:
double *A - указатель на массив коэффициентов СЛАУ
double *B - указатель на массив свободных членов СЛАУ
n - число уравнений в СЛАУ
- процедура пречатает массив коэффициентов и свободных членов СЛАУ в виде матрицы.

size_t stringLength(const char *str)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Аргументы:
const char *str - указатель на строку
- функция возвращает количество символов в строке str.
Перебирает все символы, пока не встретится символ('\0') и увеличивает
счётчик. Когда встречается первый нулевой символ возвращает значение счётчика.

_______________________________________________________
int stringComp(const char *str1, const char *str2)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Аргументы:
const char *str1 - указатель на первую строку
const char *str2 - указатель на вторую строку
- функция посимвольно сравнивает две строки (str1 и str2) и выдает:
	-1 - когда длины двух строк разные или эти строри разные
	 0 - когда две строки совпадают
	 
__________________________________________________________________________
int lss_46_02(int n, double *A, double *B, double *X, tmp)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Аргументы:
n - размерность матрицы (количество уравений и неизвестных)
*A - указатель на массив элементов матрицы (коэф. при неизвестных в уравении, одномерный массив.
матрица задана как последовательность а<0,0> а<0,1> ... а<0,n> .... a<n,n>)
*B - указатель на массив свободных членов
*X - указатель на массив хранящий решение СЛАУ (вначале пуст, заполняется по ходу
решения СЛАУ)
tmp -  массив дополнительной памяти
--------------------------------------------------------------------------
- Функция решатель СЛАУ методом Гаусса с выбором главного элемента по столбцу.
Переменные: i, j, max_index, max_B, counter, counter_1, counter_2, counter_3, k - целочисленные переменные используемые для перебора.
max -переменная для хранения  максимального элемента по столбцу.
tmp , tmp2, tmp3 - временные переменные хранящие значения для замены двух переменных.

Алгоритм:
~~~~~~~~~
1. Прямой ход (Полный перебор всех столбцов [0;n-1])
1.1. Нахождение максимального элемента по столбцу (в самом начале считаем, что максимальный
элемент это i*n+i-тый.) Записываем его в max. Находим максимальный элемент еще одним
перебором нижних элементов стобца (т.е. [i+1; n-1]).
1.2. Перестановка текущие стоки со строкой с максимальным элементом (abs) по столбцу с i-той строкой
1.3. Нормализация строки. Делим все элементы строки на max. Если i-тый элемент ноль, то переходим на следующую итерацию.
1.4. Вычитаем нормализованную от всех нижних строк (т.е. [i+1;n-1]) домноженную на
значение [counter_2*n + i]-того элемента (где counter_2 - индекс, используемый, для перебора оставшихся строк).
2. Обратный ход (Обратный перебор [n-1; 0])
2.1. Если значение max ноль и свободный член отлична от нуля, то система не имеет решений.
Иначе подставляем значение свободного члена на текущий X[i] и вычитаем все значения превыдущих X[j]
домноженный на коэффицент на (i*n + j)-ый элемент матрицы.

-------------------
Функция возвращает:
	-1 - когда СЛАУ решение не имеет
	 0 - когда решение найдено
----------------------------------------------------------------

epsilon по умолчанию 1e-50.



